package scrap_lattes

import (
	"context"
	"encoding/csv"
	"fmt"
	"io"
	"os"
	"time"
	"sync"

	"github.com/pkg/errors"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type ScrapLattes struct {
	// Adicione aqui os campos necessários para a conexão com bancos de dados, como clientes MongoDB, Neo4j, etc.
}

type Pesquisador struct {
	Nome                       string
	Titulo                     string
	LinkCurriculo              string
	IDLattes                   string
	DataUltimaAtualizacao      string
	Resumo                     string
	NomeCitacoesBibliograficas string
	IDLattesLink               string
	OrcidID                    string
	Formacao                   []string
	Formacoes                  []FormacaoAcademica
	PosDoutorado               []FormacaoPosDoc
	FormacoesComplementares    []FormacaoComplementar
	AtuacoesProfissionais      []AtuacaoProfissional
	LinhasPesquisa             []LinhaPesquisa
	ProjetosPesquisa           []ProjetoPesquisa       `json:"projetos_pesquisa"`
	Publicacoes                []Publicacao            `json:"publicacoes"`
	FormacaoAcademica          []Formacao              `json:"formacao_academica"`
	CursosExtraCurriculares    []Curso                 `json:"cursos_extra_curriculares"`
	ExperienciaProfissional    []Experiencia           `json:"experiencia_profissional"`
	Patentes                   []Patente               `json:"patentes"`
	MembroCorpoEditorial       []MembroCorpoEditorial  `json:"membro_corpo_editorial"`
	RevisorPeriodico           []RevisorPeriodico      `json:"revisor_periodico"`
	RevisorProjetoFomento      []RevisorProjetoFomento `json:"revisor_projeto_fomento"`
	PremiosTitulos             []PremioTitulo          `json:"premios_titulos"`
}

type FormacaoAcademica struct {
	Periodo        string
	Nivel          string
	TituloTrabalho string
	Instituicao    string
	Orientador     string
	Bolsista       string
	AreaEstudo     string
	PalavrasChave  []string
}

type FormacaoPosDoc struct {
	Periodo        string
	Nivel          string
	TituloTrabalho string
	Instituicao    string
	Orientador     string
	Bolsista       string
	AreaEstudo     string
	PalavrasChave  []string
}

type FormacaoComplementar struct {
	Periodo      string
	TituloCurso  string
	CargaHoraria string
	Instituicao  string
}

type AtuacaoProfissional struct {
	Instituicao          string
	VinculoInstitucional []VinculoInstitucional
	Atividades           []Atividade
}

type VinculoInstitucional struct {
	Periodo      string
	Descricao    string
	CargaHoraria int
}

type Atividade struct {
	Periodo        string
	Descricao      string
	Disciplinas    []string
	LinhasPesquisa []string
}

type LinhaPesquisa struct {
	Nome             string
	Objetivo         string
	GrandeArea       []string
	Area             []string
	SubArea          []string
	SetoresAtividade []string
	PalavrasChave    []string
}

type Endereco struct {
	Rua    string `json:"rua"`
	Bairro string `json:"bairro"`
	Cidade string `json:"cidade"`
	Estado string `json:"estado"`
	Pais   string `json:"pais"`
	CEP    string `json:"cep"`
}

type RedeSocial struct {
	Nome string `json:"nome"`
	URL  string `json:"url"`
}

type ProjetoPesquisa struct {
	Titulo        string     `json:"titulo"`
	Descricao     string     `json:"descricao"`
	DataInicio    *time.Time `json:"data_inicio"`
	DataTermino   *time.Time `json:"data_termino"`
	Financiamento string     `json:"financiamento"`
}

type Publicacao struct {
	Titulo  string     `json:"titulo"`
	Resumo  string     `json:"resumo"`
	Data    *time.Time `json:"data"`
	Revista string     `json:"revista"`
	Ano     string
	Autores []string
	DOI     string
}

type Formacao struct {
	Titulo       string `json:"titulo"`
	Instituicao  string `json:"instituicao"`
	AnoConclusao string `json:"ano_conclusao"`
}

type Curso struct {
	Nome          string     `json:"nome"`
	Instituicao   string     `json:"instituicao"`
	DataConclusao *time.Time `json:"data_conclusao"`
}

type Experiencia struct {
	Posicao string     `json:"posicao"`
	Empresa string     `json:"empresa"`
	Inicio  *time.Time `json:"inicio"`
	Termino *time.Time `json:"termino"`
}

type Patente struct {
	Titulo string `json:"titulo"`
	Resumo string `json:"resumo"`
	Ano    int    `json:"ano"`
}

type MembroCorpoEditorial struct {
	Periodo   Periodo `json:"periodo"`
	Periodico string  `json:"periodico"`
}

type Periodo struct {
	Inicio  *time.Time `json:"inicio"`
	Termino *time.Time `json:"termino"`
}

type RevisorPeriodico struct {
	Periodo   Periodo `json:"periodo"`
	Periodico string  `json:"periodico"`
}

type RevisorProjetoFomento struct {
	Periodo        Periodo `json:"periodo"`
	AgenciaFomento string  `json:"agencia_fomento"`
}

type PremioTitulo struct {
	Ano       int    `json:"ano"`
	Descricao string `json:"descricao"`
}

// Funcionalidades:

func (ScrapLattes) ScrapeData(filePath string) error {
	// Abra o arquivo CSV
	file, err := os.Open(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	// Crie um leitor CSV para ler o conteúdo do arquivo
	reader := csv.NewReader(file)

	// Faça o processamento dos dados do CSV
	for {
		record, err := reader.Read()
		if err != nil {
			// Verifique se chegou ao final do arquivo
			if err == io.EOF {
				break
			}
			return err
		}

		// Extraia as informações desejadas do registro (linha) do CSV
		// e realize as operações necessárias

		// Exemplo: exibir as informações extraídas
		fmt.Println("Nome:", record[0])
		fmt.Println("Título:", record[1])
		// ... exiba outras informações conforme necessário
		fmt.Println("---")
	}

	return nil
}


//Estrutura de dados do arquivo CSV que é entrada de dados para scrap
type DadosDocente struct {
	Nome     string
	Lattes   string
	PPGCS    string
	Fiocruz  string
	Categoria string
}

func (d *DadosDocente) Processar() {
	// Aqui seria a lógica para processar cada linha do CSV, por exemplo, realizar a raspagem dos dados do Lattes
	// Suponha que a função "rasparDadosLattes(d.Lattes)" faça a raspagem
	//rasparDadosLattes(d.Lattes)
	fmt.Println("Nome:", d.Nome)
	fmt.Println("Lattes:", d.Lattes)
	// ... exiba outras informações conforme necessário
	fmt.Println("---")
}

func (s *ScrapLattes) ExtrairDados(caminhoArquivo string) error {
	c := make(chan *DadosDocente)

	var wg sync.WaitGroup
	wg.Add(1)

	go func() {
		erro := s.lerCSV(caminhoArquivo, c, &wg)
		if erro != nil {
			fmt.Println("Erro:", erro)
			os.Exit(1)
		}
	}()

	go func() {
		for dados := range c {
			dados.Processar()
		}
	}()

	wg.Wait()
	return nil
}

func (s *ScrapLattes) lerCSV(caminhoArquivo string, c chan<- *DadosDocente, wg *sync.WaitGroup) error {
	defer wg.Done()
	// Abra o arquivo CSV
	arquivo, erro := os.Open(caminhoArquivo)
	if erro != nil {
		return erro
	}
	defer arquivo.Close()

	// Crie um leitor CSV para ler o conteúdo do arquivo
	leitor := csv.NewReader(arquivo)

	// Faça o processamento dos dados do CSV
	for {
		registro, erro := leitor.Read()
		if erro != nil {
			if erro == io.EOF {
				break
			}
			return erro
		}
		// Criando a estrutura de dados com as informações do CSV
		dados := &DadosDocente{
			Nome:     registro[0],
			Lattes:   registro[1],
			PPGCS:    registro[2],
			Fiocruz:  registro[3],
			Categoria: registro[4],
		}
		// Enviando os dados para o canal
		c <- dados
	}
	return nil
}

// Funções para extrair cada seção de cada currículo
func ObterDocente(IDLattes string) (*Docente, error) {
	// Configurar a conexão com o banco de dados MongoDB
	client, err := mongo.NewClient(options.Client().ApplyURI("mongodb://localhost:27017"))
	if err != nil {
		return nil, fmt.Errorf("falha ao criar cliente MongoDB: %v", err)
	}

	// Conectar ao servidor MongoDB
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	err = client.Connect(ctx)
	if err != nil {
		return nil, fmt.Errorf("falha ao conectar ao servidor MongoDB: %v", err)
	}

	// Desconectar do servidor MongoDB no final
	defer func() {
		if err := client.Disconnect(ctx); err != nil {
			fmt.Printf("falha ao desconectar do servidor MongoDB: %v\n", err)
		}
	}()

	// Acessar o banco de dados e a coleção
	db := client.Database("nome_do_banco_de_dados")
	collection := db.Collection("nome_da_colecao")

	// Consultar o docente pelo IDLattes
	filter := bson.D{{Key: "IDLattes", Value: IDLattes}}
	var docente Docente

	err = collection.FindOne(ctx, filter).Decode(&docente)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("docente não encontrado")
		}
		return nil, fmt.Errorf("falha ao consultar docente: %v", err)
	}

	return &docente, nil
}

func (ScrapLattes) SalvarDocente(docente *Docente) error {
	// Configurar a conexão com o banco de dados MongoDB
	client, err := mongo.NewClient(options.Client().ApplyURI("mongodb://localhost:27017"))
	if err != nil {
		return fmt.Errorf("falha ao criar cliente MongoDB: %v", err)
	}

	// Conectar ao servidor MongoDB
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	err = client.Connect(ctx)
	if err != nil {
		return fmt.Errorf("falha ao conectar ao servidor MongoDB: %v", err)
	}

	// Desconectar do servidor MongoDB no final
	defer func() {
		if err := client.Disconnect(ctx); err != nil {
			fmt.Printf("falha ao desconectar do servidor: %v\n", err)
		}
	}() 
			
func (s *ScrapLattes) ExtrairDados(caminhoArquivo string) error {
	// Abra o arquivo CSV
	arquivo, erro := os.Open(caminhoArquivo)
	if erro != nil {
		return erro
	}
	defer arquivo.Close()

	// Crie um leitor CSV para ler o conteúdo do arquivo
	leitor := csv.NewReader(arquivo)

	// Faça o processamento dos dados do CSV
	for {
		registro, erro := leitor.Read()
		if erro != nil {
			// Verifique se chegou ao final do arquivo
			if erro == io.EOF {
				break
			}
			return erro
		}

		// Extraia as informações desejadas do registro (linha) do CSV
		// e realize as operações necessárias

		// Exemplo: exibir as informações extraídas
		fmt.Println("Nome:", registro[0])
		fmt.Println("Título:", registro[1])
		// ... exiba outras informações conforme necessário
		fmt.Println("---")
	}

	return nil
}

func ObterDocente(IDLattes string) (*Docente, error) {
	// Configurar a conexão com o banco de dados MongoDB
	cliente, erro := mongo.NewClient(options.Client().ApplyURI("mongodb://localhost:27017"))
	if erro != nil {
		return nil, fmt.Errorf("falha ao criar cliente MongoDB: %v", erro)
	}

	// Conectar ao servidor MongoDB
	ctx, cancelar := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancelar()

	erro = cliente.Connect(ctx)
	if erro != nil {
		return nil, fmt.Errorf("falha ao conectar ao servidor MongoDB: %v", erro)
	}

	// Desconectar do servidor MongoDB no final
	defer func() {
		if erro := cliente.Disconnect(ctx); erro != nil {
			fmt.Printf("falha ao desconectar do servidor MongoDB: %v\n", erro)
		}
	}()

	// Acessar o banco de dados e a coleção
	db := cliente.Database("nome_do_banco_de_dados")
	colecao := db.Collection("nome_da_colecao")

	// Consultar o docente pelo IDLattes
	filtro := bson.D{{Key: "IDLattes", Value: IDLattes}}
	var docente Docente

	erro = colecao.FindOne(ctx, filtro).Decode(&docente)
	if erro != nil {
		if erro == mongo.ErrNoDocuments {
			return nil, fmt.Errorf("docente não encontrado")
		}
		return nil, fmt.Errorf("falha ao consultar docente: %v", erro)
	}

	return &docente, nil
}

func (s *ScrapLattes) SalvarDocente(docente *Docente) error {
	// Configurar a conexão com o banco de dados MongoDB
	cliente, erro := mongo.NewClient(options.Client().ApplyURI("mongodb://localhost:27017"))
	if erro != nil {
		return fmt.Errorf("falha ao criar cliente MongoDB: %v", erro)
	}

	// Conectar ao servidor MongoDB
	ctx, cancelar := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancelar()

	erro = cliente.Connect(ctx)
	if erro != nil {
		return fmt.Errorf("falha ao conectar ao servidor MongoDB: %v", erro)
	}

	// Desconectar do servidor MongoDB no final
	defer func() {
		if erro := cliente.Disconnect(ctx); erro != nil {
			fmt.Printf("falha ao desconectar do servidor MongoDB: %v\n", erro)
		}
	}()

	// Acessar o banco de dados e a coleção
	db := cliente.Database("nome_do_banco_de_dados")
	colecao := db.Collection("nome_da_colecao")

	// Inserir o docente no banco de dados
	_, erro = colecao.InsertOne(ctx, docente)
	if erro != nil {
		return fmt.Errorf("falha ao inserir docente: %v", erro)
	}

	return nil
}
		
